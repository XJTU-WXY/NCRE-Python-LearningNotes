# 数据库设计基础
### 基本概念
数据处理的最小单位是**数据项**，若干数据项构成**数据元素**，**数据**是能够被计算机识别、存储加工的信息载体，**数据结构**是数据之间的相互关系和数据运算。
#### 构成
- **数据库系统DBS**：
  - **数据库DB**： 长期存储的有组织可共享的数据集合（**数据集成、数据共享**）
  - **数据库管理系统DBMS**：数据库系统的核心
  - 数据库管理员
  - 硬件平台
  - 软件平台
#### 数据管理发展的三个阶段
1. 人工管理阶段：无共享，冗余度大，数据无结构
2. 文件系统阶段：共享性差，冗余度大，记录内有结构（**整体无结构**）
3. 数据库系统阶段：**共享性高（根本问题）**，**冗余度小**，高度的**物理独立性**，一定的**逻辑独立性**，整体结构化，用数据模型描述
     - 数据独立性：数据与程序互不依赖
#### 数据库管理的特点
1. **集成性**：数据库中存储的数据是一个**整体**，按照一定的**结构**进行组织，而不是分散在各个独立的文件中。
2. **高共享性、低冗余性**：不同用户和程序可以访问相同的数据，避免重复存储，提高存储利用率。
3. **独立性**：
     - 物理独立性：数据的存储方式可以改变，但**不会影响应用程序**。
     - 逻辑独立性：数据结构的改变不会影响数据的存储方式。
4. **统一管理与控制**
#### 数据库系统的体系结构
- **三级模式**
  1. **外模式**（子模式/用户模式）：每个用户对数据库的视图，可有**任意多个**。
      > 例如：某个用户只能看到 "学生表" 的姓名和学号，而另一个用户可以访问全部字段。
  2. **概念模式**：全局数据**逻辑结构**的描述，定义所有数据的组织方式、关系、约束等。
  3. **内模式/物理模式**：物理存储结构，描述数据在磁盘上的存储方式，如索引、存储块等
- **两级映射**
  - **外模式 → 概念模式**：保证用户视图与数据库逻辑结构的独立性。
  - **概念模式 → 内模式**：保证数据库逻辑结构与物理存储的独立性。
#### 数据库语言
- 数据定义语言DDL：定义数据模型
- 数据操纵语言DML：增删改查
- 数据控制语言DCL：数据完整性、安全性的定义，故障恢复等功能
---
### 数据模型
#### 三要素:
1. **数据结构**：数据库中数据的组织方式，如表、字段、关系等。
2. **数据操作**：对数据的基本操作，如增删改查
3. **数据约束**：对数据的完整性、正确性、有效性进行限制的规则。
#### 类型:
1. **概念数据模型**——⭐**E-R模型/实体联系模型**:
![](https://www.edrawsoft.cn/images/creat/stgxit.png)
  - **实体（矩形）**：客观存在的具体单位，如“学生”
  - **属性（椭圆形）**：实体的特性，如“姓名”“学号”。
  - **联系（菱形）**：实体间的关系，如“学生-选课”
    - **一对一（1:1）**：“国家-总统”
    - **一对多（1:M）**：“班级-学生”
    - **多对多（M:N）**：“学生-课程”
  
1. **逻辑数据模型**：
  - **层次模型**：**树形**结构，自顶向下
  - **网状模型**：**网络**结构，一个结点可以没有或有多个父节点
  - **关系模型（最常用）**——**二维表（TABLE）**：
    - **概念**：
      - **关系**：表
      - **属性**：表的**列**，如“姓名”。
        - **值域**：属性值的取值范围
        - **键**：
           - **候选键**：可以唯一标识元组的**一组**属性，如“学号”和“身份证号”
           - **主键**：在候选键中选择一个作为主键，如“学号”。
           - **外键**：一个表中的某个字段，引用**另一个表的主键**，如“课程表”的“教师编号”是“教师表”的外键。
      - **元组**：表的**行**，如一个学生的完整信息。
      
    - **完整性约束**：
      - **实体完整性（最基本）**：主键属性值不为空
      - **参照完整性**：外键必须引用一个存在的元组，如“选课表”中的课程编号必须存在于“课程表”中。
      - **用户定义的完整性**：业务逻辑规定的约束，如“年龄必须大于 18”。
2. **物理数据模型/物理模型**
---
### 数据库设计与管理
#### 数据库设计的4阶段
1. **需求分析**
2. **概念设计**：使用 **E-R 模型** 设计数据结构。
3. **逻辑设计**：转换为 **关系模型**，进行 **规范化** 处理。
4. **物理设计**:确定存储方案、索引、优化查询等。
#### 转换规则：将E-R模型转换为关系模型
|E-R模型|关系模型|
|-------|-------|
|实体|元组|
|属性|属性|
|联系|关系|
|实体集|关系|
#### 规范化理论：克服逻辑结构中的插入异常、删除异常、数据冗余等问题
- **第一范式（1NF）：** 所有字段必须是原子值，不可再分。(不能包含**一列多值**)
  - **不符合 1NF 的示例**
    | 学号 | 姓名 | 电话号码 |
    |------|------|--------------------|
    | 1001 | 张三 | 13800000000, 13911111111 |
    | 1002 | 李四 | 13722222222 |
- **第二范式（2NF）：** 在满足1NF的基础之上，消除**部分依赖**，非主属性必须完全依赖主键。（不能只依赖主键的一部分）
  - **不符合 2NF 的示例** (`课程ID`, `学生ID`) 组成联合主键。
    | 课程ID | 学生ID | 课程名称 | 学生姓名 | 成绩 |
    |--------|--------|----------|----------|------|
    | C001   | S001   | 数据库   | 张三     | 90   |
    | C002   | S001   | 操作系统 | 张三     | 85   |
    | C001   | S002   | 数据库   | 李四     | 88   |
    > **问题**：
    > - `课程名称` **仅依赖于 `课程ID`**，与 `学生ID` 无关。
    > - `学生姓名` **仅依赖于 `学生ID`**，与 `课程ID` 无关。
    > - 发生**部分依赖**，不符合 2NF。
    
    > **将其转换为 2NF**:
    >
    >拆分成两个表：
    >
    > **学生表**
    > | 学生ID | 学生姓名 |
    > |--------|----------|
    > | S001   | 张三     |
    > | S002   | 李四     |
    > 
    > **课程表**
    > | 课程ID | 课程名称 |
    > |--------|----------|
    > | C001   | 数据库   |
    > | C002   | 操作系统 |
    > 
    > **选课成绩表**
    > | 课程ID | 学生ID | 成绩 |
    > |--------|--------|------|
    > | C001   | S001   | 90   |
    > | C002   | S001   | 85   |
    > | C001   | S002   | 88   |
- **第三范式（3NF）：** 在满足2NF的基础之上，消除**传递依赖**，确保数据不依赖于非主属性。(非主属性必须直接依赖于主键)
  - **不符合 3NF 的示例** 主键：`学号`
    | 学号 | 姓名 | 班级 | 班主任 |
    |------|------|------|--------|
    | 1001 | 张三 | 1班  | 王老师 |
    | 1002 | 李四 | 2班  | 李老师 |
    | 1003 | 王五 | 1班  | 王老师 |
    > **问题**：
    > - `班主任` **依赖于 `班级`**，但 `班级` **依赖于 `学号`**。
    > - `学号` → `班级`，`班级` → `班主任`，形成**传递依赖**。

    > **将其转换为 3NF**
    > 拆分成两个表：
    >
    > **学生表**
    > | 学号 | 姓名 | 班级 |
    > |------|------|------|
    > | 1001 | 张三 | 1班  |
    > | 1002 | 李四 | 2班  |
    > | 1003 | 王五 | 1班  |
    >
    > **班级表**
    > | 班级 | 班主任 |
    > |------|--------|
    > | 1班  | 王老师 |
    > | 2班  | 李老师 |


---
### 关系代数
#### 基本运算符
- **集合运算符**：
  - **并** $∪$：两个表的并集，去重后返回所有行。
  - **交** $∩$：两个表的交集，返回共同的行。
  - **差** $-$：返回第一个表有但第二个表没有的行。
  - **笛卡尔积** $×$：**将两个表中的每一行进行组合**，形成所有可能的配对。（逐个配对，列相加，行相乘）
    - **示例**
  
        **学生（Student）**
        | 学号 | 姓名 |
        |------|------|
        | 1001 | 张三 |
        | 1002 | 李四 |

        **课程（Course）**
        | 课程号 | 课程名 |
        |------|------|
        | C01   | 数据库 |
        | C02   | 计算机网络 |

        查询**所有学生与课程的组合**：$\text{Student} × \text{Course}$

        **执行过程**：
        - 每个学生配对每门课程。

        **结果**：
        | 学号 | 姓名 | 课程号 | 课程名 |
        |------|------|------|------|
        | 1001 | 张三 | C01  | 数据库 |
        | 1001 | 张三 | C02  | 计算机网络 |
        | 1002 | 李四 | C01  | 数据库 |
        | 1002 | 李四 | C02  | 计算机网络 |
- **关系运算符**：
  - **选择** $σ$：按条件选取满足要求的行。
  - **投影** $π$：按条件选取满足要求的行。
  - **连接** $⋈$：
    - **自然连接**（$R⋈S$）：按两个表的共有列进行连接，共有列值相同的行将会连接。
    - **等值连接**（$R⋈_{i=j}S$）：对两个表中非共有的列（一个是i和一个是j）的值相同的行进行连接
  - **除** $÷$：（笛卡尔积的逆运算）：
    1. 先从R中选出属性值与S全等的行
    2. 再从R中去掉所有与S共有的列
